<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Hive Partitioning: Tips and Hows Â· Codailama</title><meta name="description" content="Hive Partitioning: Tips and Hows - Santosh Pingale"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://codailama.com/atom.xml" title="Codailama"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://in.linkedin.com/in/santoshpingale" target="_blank" class="nav-list-link">LINKEDIN</a></li><li class="nav-list-item"><a href="https://github.com/santosh-d3vpl3x" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Hive Partitioning: Tips and Hows</h1><div class="post-info">Mar 6, 2015</div><div class="post-content"><p>After having used Hive for sometime now, I can really say, it has provided some serious productivity boost. Not only that, it is really easy to maintain and most of the things are transparent to the developer. Really huge amount of data can be efficiently crunched using Hive!</p>
<a id="more"></a>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#hive-partitioning-an-overview">Hive Partitioning: An Overview</a></li>
<li><a href="#defining-a-partitioned-table">Defining a Partitioned Table</a><ul>
<li><a href="#while-creating-table">While Creating Table</a></li>
</ul>
</li>
<li><a href="#adding-data-to-partitioned-table">Adding Data to Partitioned Table</a><ul>
<li><a href="#using-staging-table">Using Staging Table</a></li>
<li><a href="#load-data-inpath">Load Data Inpath</a></li>
<li><a href="#copy-data-data-and-perform-alter-table">Copy Data Data and Perform Alter Table</a></li>
</ul>
</li>
<li><a href="#partitioning-methodology">Partitioning Methodology</a><ul>
<li><a href="#static-partitioning">Static Partitioning</a></li>
<li><a href="#dynamic-partitioning">Dynamic Partitioning</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#tips-and-precautions">Tips and Precautions</a></li>
<li><a href="#references">References</a></li>
</ul>
<!-- tocstop -->
<p></div></p>
<h2 id="hive-partitioning-an-overview"><a href="#Hive-Partitioning-An-Overview" class="headerlink" title="Hive Partitioning: An Overview"></a>Hive Partitioning: An Overview <a href="#hive-partitioning-an-overview" class="header-anchor">#</a></h2><p>By design, Hive is a DWH built on top of HDFS and MR. It is built for very large datasets. Behind the scene, Hive also spawns MapReduce. With existing data volume and velocity at which new data is flowing in would cause system to reach a point where processing would end up hogging all the available resource.<br><img src="http://130.211.135.58/wp-content/uploads/2015/03/HivePartitioning-UnpartitionedTable.png" alt="Data Processing - Unpartitioned Table"><br>Lets imagine a scenario, if we were to dump all the access logs from servers to HDFS, we will simply build a hive table on top of it. The data will start flowing in it on daily basis. We start appending data to HDFS directory. Six months later, some issue occurs in production and only one week duration of access log data is required for its analysis. We will need to execute query on date column which will iterate over all the rows from all the files in the HDFS dir. A full table scan is performed for such a trivial task. Wouldn&#x2019;t it be nice to have feature which will allow us to readily fetch data for only those seven days? Hive partitioning provides exactly that!<br><img src="http://130.211.135.58/wp-content/uploads/2015/03/HivePartitioning-partitionedTable-1024x465.png" alt="Data Processing - Partitioned Table"><br>Generally a MapReduce program reads all the files provided as input and then as per code logic, it starts applying filters, aggregations, etc. For large data sets this method is very inefficient. In most of the cases, table users know the frequently used columns for querying.<br>For example: Most of the time, queries performed over log data have date in where clause. Sample query for access logs would be &#x201C;give me all the 404 which occurred yesterday&#x201D;.</p>
<p>In such cases it makes sense to make all frequently queried column related data readily queryable! Hive partitioning helps in organizing such data in separate directories. As a result, all the data related to a particular column value is put under a directory. When a query is executed with partition column in criteria, instead of performing a full table scan, all the data belonging to that partition directory is fetched and processed which greatly reduces amount of data crunched.</p>
<p>Lets see how to create a partitioned table and ways in which data can be pumped into it. Then how can we use partitions efficiently and what precautions we should take while dealing with partitions.</p>
<h2 id="defining-a-partitioned-table"><a href="#Defining-a-Partitioned-Table" class="headerlink" title="Defining a Partitioned Table"></a>Defining a Partitioned Table <a href="#defining-a-partitioned-table" class="header-anchor">#</a></h2><p>Hive language manual is one of the very well written documentation on www. It clearly explains every little detail in a very intuitive manner. Lets use it and create a table which is partitioned. We will use the same case explained earlier. The <code>demographic</code> table would be partitioned by <code>BirthDate</code> column.</p>
<h3 id="while-creating-table"><a href="#While-Creating-Table" class="headerlink" title="While Creating Table"></a>While Creating Table <a href="#while-creating-table" class="header-anchor">#</a></h3><p>Most of the time we know details about data which is going to flow in system. Hence, we can instruct Hive to create partitioned table.<br>Syntax:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PARTITIONED_TABLE </div><div class="line">(column_name column_type)</div><div class="line">PARTITIONED <span class="keyword">BY</span> </div><div class="line">(partition_column partition_type) </div><div class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> ... </div><div class="line">LOCATION ...</div></pre></td></tr></table></figure></p>
<p>So <code>demographic</code> table DDL will look like:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DEMOGRAPHIC(</div><div class="line">     GENDER <span class="keyword">string</span>,</div><div class="line">     <span class="keyword">NAME</span> <span class="keyword">string</span>,</div><div class="line">     CITY <span class="keyword">string</span>,</div><div class="line">     COUNTRY <span class="keyword">string</span>,</div><div class="line">     BIRTHDATETIME <span class="keyword">string</span>)</div><div class="line">    PARTITIONED <span class="keyword">BY</span> (</div><div class="line">     BirthDate <span class="keyword">string</span></div><div class="line">    )</div><div class="line">    <span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE</div><div class="line">    LOCATION <span class="string">&apos;/app/person/demographic&apos;</span></div></pre></td></tr></table></figure>
<p>What is the difference between unpartitioned table and partitioned table in this case? <code>BirthDate</code> column would become a pseudo column. Actual files will not contain any data for <code>Birthdate</code>, rather it will be derived from directory name.<br>When our table is partitioned by <code>Birthdate</code> then we will have directory <code>/app/person/demographic/BirthDate=2015-01-01</code> and this directory will have following structure when selected from hive query.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Gender</th>
<th style="text-align:right">Name</th>
<th style="text-align:center">City</th>
<th style="text-align:center">Country</th>
<th style="text-align:center">BirthDateTime</th>
<th style="text-align:center">BirthDate</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Male</td>
<td style="text-align:right">Jack</td>
<td style="text-align:center">NY</td>
<td style="text-align:center">US</td>
<td style="text-align:center">2015-01-01 01:23:39</td>
<td style="text-align:center">2015-01-01</td>
</tr>
<tr>
<td style="text-align:center">Male</td>
<td style="text-align:right">Kent</td>
<td style="text-align:center">LON</td>
<td style="text-align:center">UK</td>
<td style="text-align:center">2015-01-01 04:43:40</td>
<td style="text-align:center">2015-01-01</td>
</tr>
<tr>
<td style="text-align:center">Female</td>
<td style="text-align:right">Rossie</td>
<td style="text-align:center">SYD</td>
<td style="text-align:center">AUS</td>
<td style="text-align:center">2015-01-01 12:31:30</td>
<td style="text-align:center">2015-01-01</td>
</tr>
</tbody>
</table>
<p>You can execute query with partition column in where clause and you can see huge performance boost. If all partitions are uniformly sized and there are about 1000 partitions, it will take only 7/1000th of cumulative CPU time as compared to the case of non partitioned table.</p>
<h2 id="adding-data-to-partitioned-table"><a href="#Adding-Data-to-Partitioned-Table" class="headerlink" title="Adding Data to Partitioned Table"></a>Adding Data to Partitioned Table <a href="#adding-data-to-partitioned-table" class="header-anchor">#</a></h2><h3 id="using-staging-table"><a href="#Using-Staging-Table" class="headerlink" title="Using Staging Table"></a>Using Staging Table <a href="#using-staging-table" class="header-anchor">#</a></h3><p>In this strategy, we create a staging table to temporarily host the data and then we move data to final partition.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DEMOGRAPHIC_TEMP(</div><div class="line">    GENDER <span class="keyword">string</span>,</div><div class="line">     <span class="keyword">NAME</span> <span class="keyword">string</span>,</div><div class="line">     CITY <span class="keyword">string</span>,</div><div class="line">     COUNTRY <span class="keyword">string</span>,</div><div class="line">     BIRTHDATETIME <span class="keyword">string</span>)</div><div class="line">    <span class="keyword">STORED</span> <span class="keyword">AS</span> TEXTFILE</div><div class="line">    LOCATION <span class="string">&apos;/app/person/demographic&apos;</span></div></pre></td></tr></table></figure>
<p>As you might have noticed, staging table does not have any partition column, well in some use cases it is possible to create a partition column for temp table as well. To add data to temp table, we just put the data into the table location. Then using <code>INSERT INTO ... SELECT</code> query insert data into final table with correct partition.<br><img src="http://130.211.135.58/wp-content/uploads/2015/03/load-data-staging.png" alt="Loading Partitioned Table from Stagin Table"></p>
<p>We can use both static and dynamic partitioning with this strategy. They are explained in more details in subsequent section. Data transformation and cleanser can be applied while selecting the data from temp table, which adds extra flexibility. Most of the times partitioned tables carry Hive specific data formats such as ORC which are also compressed. This method supports data conversion out of the box.</p>
<h3 id="load-data-inpath"><a href="#Load-Data-Inpath" class="headerlink" title="Load Data Inpath"></a>Load Data Inpath <a href="#load-data-inpath" class="header-anchor">#</a></h3><p>File can be directly moved from HDFS directory to partitioned table using <code>LOAD DATA INPATH &apos;filepath&apos; INTO TABLE Demographic PARTITION (BirthDate=&apos;2014-01-12&apos;)</code><br><img src="http://130.211.135.58/wp-content/uploads/2015/03/load-data-direct.png" alt="Loading Partitioned Table directly"><br>This is a pure copy operation which means, we won&#x2019;t be able to apply any data transformations, file format conversions and dynamic partitioning.</p>
<h3 id="copy-data-data-and-perform-alter-table"><a href="#Copy-Data-Data-and-Perform-Alter-Table" class="headerlink" title="Copy Data Data and Perform Alter Table"></a>Copy Data Data and Perform Alter Table <a href="#copy-data-data-and-perform-alter-table" class="header-anchor">#</a></h3><p>This is very similar to <code>Load Data Inpath</code> method. But in this method we copy data manually to partition directory and then alter table to add this directory using <code>ALTER TABLE ... ADD PARTITION</code> query.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Demographic <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (BirthDate = <span class="string">&apos;2014-01-14&apos;</span>) location <span class="string">&apos;/any/location/on/hdfs&apos;</span>;</div></pre></td></tr></table></figure>
<p>We do not need to follow naming convention for this method to work. But generally you should.</p>
<h2 id="partitioning-methodology"><a href="#Partitioning-Methodology" class="headerlink" title="Partitioning Methodology"></a>Partitioning Methodology <a href="#partitioning-methodology" class="header-anchor">#</a></h2><p>The nomenclature <code>static</code> and <code>dynamic</code> depends on whether partition value is derived at runtime or at compile time.</p>
<ul>
<li><strong>Static Partitioning</strong>: The value of the partition key is provided along with the query itself. Hence, we know the exact value at the compile time itself.</li>
<li><strong>Dynamic Partitioning</strong>: The value of the partition key is derived at run time from query execution and partitions are created on the fly.</li>
</ul>
<h3 id="static-partitioning"><a href="#Static-Partitioning" class="headerlink" title="Static Partitioning"></a>Static Partitioning <a href="#static-partitioning" class="header-anchor">#</a></h3><p>Static partitioning is useful when you know exactly to which partition data in hand belong. Suppose you get a file on a daily basis for yesterday&#x2019;s data feed. Then one can easily load data in partition which is for yesterday&#x2019;s date[example:&#x2019;2014-01-01&#x2019;]. First load data in staging table i.e. <code>DEMOGRAPHIC_TEMP</code> and then load it into main partitioned table i.e. <code>DEMOGRAPHIC</code><br><code>INSERT INTO TABLE DEMOGRAPHIC PARTITION (BIRTHDATE=&apos;2014-01-01&apos;) SELECT * FROM DEMOGRAPHIC_TEMP</code><br>As you can see, we have already mentioned partition date and Hive only has to move data to this directory.</p>
<h3 id="dynamic-partitioning"><a href="#Dynamic-Partitioning" class="headerlink" title="Dynamic Partitioning"></a>Dynamic Partitioning <a href="#dynamic-partitioning" class="header-anchor">#</a></h3><p>Most of the time, we need to consume files which have data for multiple partitions. It is inconvenient to separate data for each partition by filtering and then add this data one by one by using static partitioning. Hive provides a very useful feature of dynamic partitioning. You just need to use <code>INSERT INTO ... SELECT</code> syntax with few dynamic partitioning related parameters set. Hive will automatically filter the data, create directories, move filtered data to appropriate directory and create partition over it.<br>Parameters which should be set:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> hive.exec.dynamic.partition=<span class="literal">true</span>;</div><div class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode=nonstrict;</div><div class="line"><span class="keyword">set</span> hive.exec.max.dynamic.partitions.pernode={appropriate <span class="built_in">int</span> val}</div><div class="line"><span class="keyword">set</span> hive.exec.max.dynamic.partitions={appropriate <span class="built_in">int</span> val}</div></pre></td></tr></table></figure>
<p>The methodology would remain the same,first load data in staging table i.e. <code>DEMOGRAPHIC_TEMP</code> and then load it into main partitioned table i.e. <code>DEMOGRAPHIC</code><br><code>INSERT INTO TABLE DEMOGRAPHIC PARTITION (BIRTHDATE) SELECT *,to_date(BIRTHDATETIME) FROM DEMOGRAPHIC_TEMP</code><br>We have only mentioned partition column and It&#x2019;s Hive&#x2019;s responsibility to add data to appropriate directory. Hive will use last column to deduce the partition for data. As you can see, I have used <code>to_date</code> UDF to convert &#x2018;2014-01-01 02:02:20&#x2019; to &#x2018;2014-01-01&#x2019;. That is because I do not want to end up creating partition at second&#x2019;s granularity.<br>If <code>SELECT to_date(BIRTHDATETIME) FROM DEMOGRAPHIC_TEMP GROUP BY to_date(BIRTHDATETIME)</code> gives four values, then four partitions would be created for those four values.</p>
<h2 id="conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion <a href="#conclusion" class="header-anchor">#</a></h2><p>With fairly huge dataset, it would take ages to perform even simpler queries. But with the help of Hive partitioning, we can perform queries more efficiently where only subset of data is data to be processed. Hive provides greater flexibility to create partitions, maintain partitions and remove them if necessary.<br>I have also seen some extra advantages such as ability to clean data for only few partitions. I would have had nightmares if I had to do it for nonpartitioned tables.<br>But still if someone wants to query complete dataset then hive partitioning is not going to help. As well over partitioning can end up causing more troubles than gains. With great power comes , great responsibility.</p>
<h2 id="tips-and-precautions"><a href="#Tips-and-Precautions" class="headerlink" title="Tips and Precautions"></a>Tips and Precautions <a href="#tips-and-precautions" class="header-anchor">#</a></h2><p>Hive can be used to advantage, if we follow good practices and take some precautions. Taking into consideration, NameNode capacity, available resources and gain we want from partitioning we can make a call about table definition.</p>
<ul>
<li><strong>Do not Abuse Dynamic Partitioning</strong>: Dynamic partitioning is a great addition to Hive. But it is too easy to abuse it. Suppose, I know that a particular dataset belongs to a particular partition. If in this case, I use dynamic partitions, then I am spawning unnecessary Reducers to partition data making process inefficient.</li>
<li><strong>Use of <code>MSCK REPAIR TABLE</code></strong>: If we have data in appropriate format i.e. in tables FileFormat and we know exact partition for that data then we can just create a directory with proper naming convention in table location and perform <code>MSCK REPAIR TABLE TABLE_NAME</code> to add those partition to table. This is particularly useful when I am moving data from one location to another. Also if in case few partition directories were removed and table is external, then table&#x2019;s metadata won&#x2019;t be updated automatically. So Hive will still be looking for this partition folder and error out. To prevent this from happening, perform <code>MSCK REPAIR</code> and you should be good.</li>
<li><strong>Prohibit Yourself from Overwhelming NameNode</strong>: While making use of dynamic partitioning, one should take care of no of partitions which could be generated as a output of <code>SELECT</code> query. If too many partitions are produced then Hive will try to create that many directories and move files to those directories putting strain on our beloved NameNode.</li>
<li><strong>Use <code>INSERT OVERWRITE ... SELECT</code> Cautiously</strong>: This one holds true for dynamic partitioning. If file being processed dynamically contains only few rows in source table for already existing partition in destination table, then you run into risk of that data being overwritten. This approach has the potential of data loss. If there are multiple partition columns, then you can partially specify partition column value to lower the risk.</li>
<li><strong>Include Partitioned Column in <code>WHERE</code> clause</strong>: To use partitioned column properly, one should always include it in the <code>WHERE</code> clause. Otherwise, partitioned columns are pretty much useless.</li>
<li><strong>Check of Cardinality of Data</strong>: Data partitioning with high cardinality is going to create large number of partitions with very small amount of data in it. NameNode and in turn your cluster admin are not going to like it.</li>
<li><strong>Do not create too many [Nested] Partitions</strong>:This is same as that of cardinality of data.</li>
<li><strong>For small dataset, better off with unpartitioned table</strong>: Smaller datasets should not be partitioned. You won&#x2019;t loose much performance by not partitioning the data.</li>
<li><strong>Apply Transformations, if necessary</strong>: Apply transformations before creating partitions dynamically. Staging table approach can easily deal with most of the transformation requirements. One example would be to convert DateTime column to Date column. Trim the data, as values with spaces would be treated as valid values.</li>
<li><strong>Keep Raw fields, if you can</strong>: If you are going to apply transformations before creating partitioned column value, make sure you also keep raw data as well. If DateTime column is converted into Date column then it would be impossible to perform query which needs Hourly resolution.</li>
</ul>
<h2 id="references"><a href="#References" class="headerlink" title="References"></a>References <a href="#references" class="header-anchor">#</a></h2><ul>
<li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-CreateTable" target="_blank" rel="external">Hive Language Manual - Create Table</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-AddPartitions" target="_blank" rel="external">Hive Language Manual - Alter Table</a></li>
<li><a href="https://issues.apache.org/jira/browse/HIVE-936" target="_blank" rel="external">Dynamic Partition Request JIRA</a></li>
</ul>
</div><p></p></article></div></section><footer><div class="paginator"><a href="/2015/03/07/issuefix-missing-artifact/" class="prev">PREV</a><a href="/2015/03/04/hdfs-explained-as-comic/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'codefudge';
var disqus_identifier = '2015/03/06/hive-partitioning-tips-and-hows/';
var disqus_title = 'Hive Partitioning: Tips and Hows';
var disqus_url = 'http://codailama.com/2015/03/06/hive-partitioning-tips-and-hows/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//codefudge.disqus.com/count.js" async></script><div class="copyright"><p>Â© 2013 - 2016 <a href="http://codailama.com">Santosh Pingale</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-6516328-4",'auto');ga('send','pageview');</script></body></html>